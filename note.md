# JAVA集合

*Collection类的集合可以理解为主要存放的是**单个对象**，⽽Map类的集合主要存储的是* 
***key-value类型的对象***

***数据结构*** 
*ArrayXxx:底层数据结构是数组，查询快，增删慢* 
*LinkedXxx:底层数据结构是链表，查询慢，增删快* 
*HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()* 
*TreeXxx:底层数据结构是二叉树。两种方式排序：**自然排序和比较器排序***

**—  List 有序,可重复**

ArrayList
优点: 底层数据结构是数组，查询快，增删慢。
缺点: 线程不安全，效率高
Vector
优点: 底层数据结构是数组，查询快，增删慢。
缺点: 线程安全，效率低
LinkedList
优点: 底层数据结构是链表，查询慢，增删快。
缺点: 线程不安全，效率高

**—Set    无序,唯一**

HashSet
底层数据结构是哈希表。(无序,唯一)
如何来保证元素唯一性?
1.依赖两个方法：hashCode()和equals()

LinkedHashSet
底层数据结构是链表和哈希表。(FIFO插入有序,唯一)
1.由链表保证元素有序
2.由哈希表保证元素唯一

TreeSet
底层数据结构是红黑树。(唯一，有序)

1. 如何保证元素排序的呢?
  自然排序
  比较器排序
2. 如何保证元素唯一性的呢?
  根据比较的返回值是否是0来决定

-----

## **List和Set总结**

1. List,Set都是继承自Collection接口，Map则不是 

2. List特点：有放入顺序，可重复 ，Set特点：无放入顺序，不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的**HashCode**决定的，其位置其实是固定的，加入Set 的Object必须定义**equals()**方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）  

3. List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。

     Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。  

-----

## **ArrayList与LinkedList的区别和适用场景** 

1. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。  
2. 对于随机访问get和set，ArrayList得优于LinkedList，因为LinkedList要移动指针。  
3. 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。

------

##**ArrayList与Vector的区别**

1. 它们**继承的接⼝完全⼀致**，但Vector是多**线程安全**的，而ArrayList不是（Vector类中的方法很多有synchronized进行修饰）
2. 当空间不足的时候，两个类的**增加方式不同**。 
3. Vector可以设置增长因子，而ArrayList不可以。 
4. Vector是一种老的动态数组，**效率很低**，一般不赞成使用。

----

##**TreeSet, LinkedHashSet and HashSet 的区别**

- TreeSet的主要功能**用于排序**
- LinkedHashSet的主要功能用于保证FIFO即有序的集合(先进先出)
- HashSet只是**通用**的存储数据的集合

1. 排序: 
   HashSet不保证有序，LinkHashSet保证FIFO即**按插入顺序排序**，TreeSet安装内部实现排序，也可以自定义排序规则(自然排序，比较器排序)
2. 空值:
      HashSet和LinkHashSet允许存在null数据，但是TreeSet中插入null数据时会报NullPointerException
3. 效率：
Performance and Speed: HashSet插入数据最快，其次LinkHashSet，最慢的是TreeSet因为内部实现排序

------

##**HashMap、TreeMap和HashTable的区别**

- TreeMap是有序的，HashMap和HashTable是无序的。
- Hashtable是线程安全的，HashMap不是线程安全的。
- Hashtable效率较低，HashMap效率较高。
- Hashtable不允许null值，HashMap允许null值（key和value都允许）
- 父类不同：Hashtable的父类是Dictionary，HashMap的父类是AbstractMap

-----
# JAVA多线程

*多线程在**低层次上扩展**了多任务（如多进程）的概念*：一个程序（进程）同时执行多个任务。

![](img\thread_4.PNG)

**线程的核心方法**

1. Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIME_WAITING状态，但**不释放对象锁**，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。

2. Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片（可**当作执行完时间片**），由运行状态变会就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。

3. t.join()/t.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入TIME_WAITING/TIME_WAITING状态，当前线程不释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程进入就绪状态。

4. obj.wait()，当前线程调用**对象的wait()**方法，当前线程**释放对象锁**，进入**等待队列**。依靠notify()/notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。

5. obj.notify()唤醒在此对象监视器上等待的单个线程，选择是**任意性**的，但不会退出CPU，而是**继续执行到结束**。notifyAll()唤醒在此对象监视器上等待的所有线程。

     *（ **wait 和 notify 属于Object 类，这⼀对⽅法调⽤必须放置在 synchronized ⽅法或块中 **）*

![](img\thread_0.png)

-----

## **进程与线程的区别** 

- **进程：**

  进程是**资源分配**的最⼩单位，进程**拥有自己的一整套变量**，进程间的切换会有较⼤的开销，⼀个进程**包含**1--n 个线程。

- **线程：**

  线程是**cpu调度**的最⼩单位，同⼀类线程**共享代码和数据空间**，每个线程有独⽴的运⾏栈和程序计数器(PC)，线程切换开销⼩。 
1. 线程和进程⼀样分为五个阶段：创建、就绪、运⾏、阻塞、终⽌。 
2. 多进程是指操作系统能同时运⾏多个任务（程序）。 
3. 多线程是指在同⼀程序中有多个顺序流在执⾏。 

------------

**线程的实现** 

- 继承Thread类      （重写run方法）

- **实现Runnable接⼝**  （通过Thread类的构造⽅法Thread(Runnable target)）

- **匿名内部类**     *(本质上也是一个类实现了Runnable接口，重写了run方法)*

  ```java
  new Thread(new Runnable() {						
      public void run() { 逻辑代码...}			
     	}).start();
  ```

（1）在实际启动进程的时候，我们直接调⽤的并不是Thread⼦类中run⽅法，⽽是调**⽤的 Thread线程的start⽅法**，因为线程start运⾏需要本地操作系统⽀持，start启动线程会调 ⽤操作系统native函数来⽀持线程运⾏。

（2）start()⽅法的调⽤后并不是⽴即执⾏多线程代码，⽽是**使得该线程变为可运⾏态** 
（Runnable），什么时候运⾏是由操作系统决定的。 

----------

## **继承Thread和实现Runnable的区别** 

实现**Runnable接⼝**⽐**继承Thread**（操作上,更简单）类所具有的**优势**： 
- **避免点继承**（只能有一个父类）的局限，⼀个类可以继承多个接⼝。 
- 适合于**资源的共享**    *(Thread构造方法传入了类对象，相当于多个Thread操作一个类的对象)*
- 线程池只能放⼊实现Runable或callable类线程，不能直接放⼊继承Thread的类 

--------------

## **Synchronized**关键字

***-----本质：同步加锁的是⼀个对象或者⼀个类，⽽不是代码*** 

- **同步方法:**
  给一个**方法增加synchronized修饰符**之后就可以使它成为同步方法，这个方法可以是静态方法和非静态方法，但是不能是抽象类的抽象方法，也不能是接口中的接口方法。

  （线程在执行同步方法时是具有排它性的。当任意一个线程进入到一个对象的**任意一个同步方法**时，这个对象的**所有同步方法都被锁定了**，在此期间，其他任何线程都不能访问这个对象的任意一个同步方法，直到这个线程执行完它所调用的同步方法并从中退出，其他线程是可以访问这个对象的所有**非同步方法**的。）

  （当同步方法是非静态方法的时候，obj锁是它当前的对象**this**，但当同步方法是静态static的时候，obj锁是**本类.class**）

- **同步块：**

  同步块是**通过锁定一个指定的对象**，来对同步块中**包含的代码进行同步**

  - synchronized(**this**)  指同步本对象

  - synchronized(**obj** ）同步某一个对象 

  - synchronized(Object.class)  同步⼀个类，既然这个类被同步了，那么多线程对所有的类变量访问也该是同步的 

  （当JVM发现**有锁的线程异常**了之后会将它的锁**自动释放**，再由其它等待的线程拿到锁。）

  （如果一个对象既有同步方法，又有同步块，那么当其中任意一个同步方法或者同步块被某个线程执行时，这个**对象就被锁定了**，其他线程无法在此时访问这个对象的同步方法，也不能执行同步块。同步方法和同步块之间的相互制约只限于同一个对象之间，所以静态同步方法只受它所属类的其它静态同步方法的制约，而跟这个类的实例（对象）没有关系。）

*synchronized 关键字用于保护共享数据。请大家注意“共享数据”，你一定要分清哪些数据是共享数据*

-------------------------

## **如何实现线程同步**

*（为什么要使用同步？* 
*因为当我们有多个线程要同时访问同一个变量或对象时，如果这些线程中既有读又有写操作时，就会导致变量值或者对象的状态出现混乱，从而导致程序异常）*

1. **使用synchronized关键字** 

   用sychronized修饰的语句块，被该关键字修饰的语句块会被自动加上内置锁，从而实现同步。（注意：线程同步是一个**高开销**的操作，因此应当尽量减少同步的内容，通常没必要同步整个方法，**同步关键代码即可**）

2. **使用可重入锁同步**（javaSE5.0以上中新增了一个java.util.concurrent （concurrent '同步'）包来支持同步） 

   Lock是一个接口，要用户区手动释放锁。**Re en trantLock**是Lock接口的实现类（注意：需要将**unlock**加入到**finally**中，否则当程序**异常**的时候，锁没有被释放）

3. **使用特殊域变量（Volatile ‘易变的’）**

   a.volatile关键字为域变量的访问提供了一种免锁机制   

   b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新   

   c.因此每次使用该域就要重新计算，而不是使用寄存器中的值     

   d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 

4. **使用局部变量实现线程同步**

   如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。

 ***注：关于Lock对象和synchronized关键字的选择：***         

*a.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。        
b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码     
c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁* 

--------------------------

## **关于死锁**

*锁和条件不能解决多线程中的所有问题，JAVA语言没有任何东西能避免或打破死锁*

**产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生：**

（1）**互斥条件**：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
（2）**不剥夺条件**：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。
（3）**请求和保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
（4）**循环等待条件**：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有，如图1所示。

-----------------

## 代码

![](img\thread_1.PNG)

![](img\thread_2.PNG)

![](img\thread_3.PNG)

--------------

# **JAVA异常处理**

![](img\exception_1.PNG)

**1.Throwable：** 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。

 - **Error（错误）:**是程序无法处理的错误，表示运行应用程序中较严重问题。

 - **Exception（异常）:**是程序本身可以处理的异常，Exception 类有一个重要的子类 RuntimeException

 2.通常，Java的异常(包括Exception和Error)分为**可查的异常（checkedexceptions）和不可查的异常（unchecked exceptions）**。    
- **可查异常**（编译器要求必须处置的异常）： 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过

- **不可查异常**(编译器不要求强制处置的异常): 包括运行时异常（RuntimeException与其子类）和错误（Error）

**3.Exception** 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。

- **运行时异常：**都是RuntimeException类及其子类异常，运行时异常只有当代码在**运行时才发行**的异常如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常

- **非运行时异常 （编译异常）：**是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过

![](img\exception_0.PNG)

 4.在 Java 应用程序中，**异常处理机制**为：**先抛出异常，再捕捉异常**。

---------------------------------------

## **异常处理机制**

对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。

**1.捕获异常：try、catch 和 finally**

- try 块：用于捕获异常。try 块后可同时接 catch 和 finally 块，但**至少有一个块**

- catch 块：用于处理捕获到的异常。一旦某个catch捕获到匹配的异常类型，**其他的catch不再有匹配和捕获的机会**。

- finally 块：无论是否捕获或处理异常，**finally块里的语句都会被执行**。当在try块或catch块中遇到return语句时，finally语句块将在**方法返回之前被执行**。在以下4种特殊情况下，finally块不会被执行：

  1）在finally语句块中发生了异常。
  2）在前面的代码中用了System.exit()退出程序。
  3）程序所在的线程死亡。
  4）关闭CPU。

  finally语句块**不应该出现return语句**

**2.抛出异常**

1. **throws抛出异常**：

   如果一个**方法**可能会出现异常，但没有能力处理这种异常，可以在**方法声明处**用throws子句来声明抛出异常。由**调用该方法的方法**去处理（捕获）

   若**覆盖**一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的**同类或子类**。

2. **使用throw抛出异常：**

   throw总是出现在**函数体**中，用来抛出一个Throwable类型的异常。程序会在throw语句**后立即终止**，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。

   ```java
   例如抛出一个IOException类的异常对象：
       throw new IOException; //throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象
   ```

   如果抛出了可检查异常，则还应该在方法头部**声明方法可能抛出的异常类型**。该方法的调用者也必须检查处理抛出的异常。

**3.throw与throws的⽐较：** 

1、throws出现在⽅法函数头；⽽throw出现在函数体。
2、throws表示出现异常的⼀种**可能性**，并不⼀定会发⽣这些异常；throw则是抛出了异常，执⾏throw则**⼀定抛出**了某种异常对象。 
3、两者都是**消极处理异常**的⽅式（这⾥的消极并不是说这种⽅式不好），只是抛出或可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的**上层调⽤处理**。

--------------------------------------------------

##异常链

Java方法抛出的可查异常将依据调用栈、沿着方法调用的层次结构一直传递到**具备处理能力的调用方法**，最高层次**到main**方法为止。如果异常传递到main方法，而main不具备处理能力，也没有通过throws声明抛出该异常，将可能出现**编译错误**。

------------------

 **自定义异常**

  使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需**继承Exception类**即可 , 然后在方法中通过**throw关键字抛出异常对象**。

*一般情况下不自定义可检查异常*

----------------------------

##**Java常见异常**

1. **runtimeException子类:**（不强制要求处理）

   java.lang.ArrayIndexOutOfBoundsException    数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。  

   java.lang.ArithmeticException    算术条件异常。譬如：整数除零等。    

   java.lang.NullPointerException    空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等    

   java.lang.ClassNotFoundException    找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。

2. **IOException**：（必须处理）

   IOException：操作输入流和输出流时可能出现的异常。
   EOFException   文件已结束异常
   FileNotFoundException   文件未找到异常

3. **其他**

   java.lang.NumberFormatException    字符串转换为数字异常 